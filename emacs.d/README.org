* belak's emacs config

This config has been cobbled together from quite a few places.

Most notably, [[https://smf.io/dotfiles][smf's dotfiles]], [[https://github.com/dakrone/dakrone-dotfiles/blob/master/.emacs.d/settings.org][dakrone's dotfiles]], [[https://github.com/syl20bnr/spacemacs][Spacemacs]], and various other
sources.

** Setup
*** Functions

Utility functions so I don't need to remember this.

#+begin_src emacs-lisp
  (defun osx-p ()
    (eq system-type 'darwin))

  (defun gnu-linux-p ()
    (eq system-type 'gnu/linux))

  ;; Small macro to install a missing package
  (defun package-ensure-installed (package)
    (unless (package-installed-p package)
      (unless belak/did-refresh
        (package-refresh-contents)
        (setq belak/did-refresh t))
      (package-install package)))
#+end_src

*** package.el

Just in case I mess something up, we enable debugging. It gets turned
off in [[Finalization]].

#+begin_src emacs-lisp
  (setq debug-on-error t)
  (setq debug-on-quit t)
#+end_src

The first thing we need to do is bootstrap the package system.

#+begin_src emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (setq package-archives
        '(("melpa"        . "http://melpa.org/packages/")
          ("melpa-stable" . "http://stable.melpa.org/packages/")
          ("marmalade"    . "https://marmalade-repo.org/packages/")
          ("gnu"          . "http://elpa.gnu.org/packages/")))

  ;; Make sure we load everything
  (package-initialize)

  ;; We want to track if we've run a refresh this time
  (setq belak/did-refresh nil)
#+end_src

*** use-package

Next we need to load [[https://github.com/jwiegley/use-package][use-package]] so we can organize everything a
little bit better. =use-package= also includes some useful tools for
lazy-loading things when we need them to speed up the startup time.

#+begin_src emacs-lisp
  (package-ensure-installed 'use-package)

  (eval-when-compile
    (defvar use-package-verbose t)
    (require 'use-package))

  (require 'diminish)
  (require 'bind-key)

  (setq use-package-always-ensure t)
#+end_src

** Core
*** Libraries

Load up zx2c4's [[http://www.passwordstore.org/][pass]] utility so we can grab data out of it later.

#+begin_src emacs-lisp
  (use-package password-store
    :defer 5
    :commands password-store-get)
#+end_src

*** Appearance

Settings such as a default font, color scheme and modeline changes.
Note that the font should be overridden later, such as in platform
specific settings.

#+begin_src emacs-lisp
  (use-package zenburn-theme
    :config
    (defun belak/zenburn-color (color)
      (cdr (assoc (concat "zenburn-" color) zenburn-colors-alist)))
    (load-theme 'zenburn t))

  (defvar my/default-frame-font "Monospace 12")

  (setq column-number-mode t
        line-number-mode t
        ;;tooltip-use-echo-area t
        tooltip-delay 0
        tooltip-short-delay 0)

  (blink-cursor-mode 0)
#+end_src

Display a line as opposed to ^L. This is early in the config file so
most bootstrapped package logs will take advantage of this.

#+begin_src emacs-lisp
  (use-package page-break-lines
    :diminish page-break-lines-mode
    :config (global-page-break-lines-mode 1))
#+end_src

Display the fill column.

#+begin_src emacs-lisp
  (use-package fill-column-indicator
    :config
    (define-globalized-minor-mode global-fci-mode fci-mode (lambda () (fci-mode 1)))
    (global-fci-mode 1)

    ;; The rest of this is a workaround for how company mode popups
    ;; interact with fci-mode.  It can be removed when
    ;; https://github.com/company-mode/company-mode/issues/180 is fixed.
    (defvar-local company-fci-mode-on-p nil)

    (defun company-turn-off-fci (&rest ignore)
      (when (boundp 'fci-mode)
        (setq company-fci-mode-on-p fci-mode)
        (when fci-mode (fci-mode -1))))

    (defun company-maybe-turn-on-fci (&rest ignore)
      (when company-fci-mode-on-p (fci-mode 1)))

    (add-hook 'company-completion-started-hook 'company-turn-off-fci)
    (add-hook 'company-completion-finished-hook 'company-maybe-turn-on-fci)
    (add-hook 'company-completion-cancelled-hook 'company-maybe-turn-on-fci))
#+end_src

=diminish-major-mode= is a snippet from [[https://github.com/sandhu/emacs.d/blob/master/lisp/teppoudo-diminish.el][Achint Sandhu's dotfiles]].

#+begin_src emacs-lisp
  (defmacro diminish-major-mode (mode new-name)
    `(add-hook (intern (concat (symbol-name ,mode) "-hook"))
               '(lambda () (setq mode-name ,new-name))))

  ;; Make the lisp modes a bit shorter
  (diminish-major-mode 'lisp-interaction-mode "λ»")
  (diminish-major-mode 'emacs-lisp-mode "Eλ")
  (diminish-major-mode 'lisp-mode "λ")
#+end_src

*** Modeline

=smart-mode-line= is a much cleaner modeline with a few extra features.

#+begin_src emacs-lisp
  (use-package smart-mode-line
    :disabled t
    :config
    (setq sml/no-confirm-load-theme t
          sml/theme 'respectful)
    (sml/setup))
#+end_src

Because Source Code Pro works well with powerline, we define our own
theme based on the default with just the virtualenv stuff added. I use
the same settings and leave it the same as the default so it'll be
easy to update later.

#+begin_src emacs-lisp
  (use-package powerline
    :config
    (defun belak/powerline-theme ()
      "Set up my own powerline theme. This was initially lifted from the powerline package."
      (interactive)
      (setq-default mode-line-format
                    '("%e"
                      (:eval
                       (let* ((active (powerline-selected-window-active))
                              (mode-line (if active 'mode-line 'mode-line-inactive))
                              (face1 (if active 'powerline-active1 'powerline-inactive1))
                              (face2 (if active 'powerline-active2 'powerline-inactive2))
                              (separator-left (intern (format "powerline-%s-%s"
                                                              (powerline-current-separator)
                                                              (car powerline-default-separator-dir))))
                              (separator-right (intern (format "powerline-%s-%s"
                                                               (powerline-current-separator)
                                                               (cdr powerline-default-separator-dir))))
                              (lhs (list (powerline-raw (powerline-evil-tag) (powerline-evil-face))
                                         (powerline-raw "%*" nil 'l)
                                         (when powerline-display-buffer-size
                                           (powerline-buffer-size nil 'l))
                                         (when powerline-display-mule-info
                                           (powerline-raw mode-line-mule-info nil 'l))
                                         (powerline-buffer-id nil 'l)
                                         (when (and (boundp 'which-func-mode) which-func-mode)
                                           (powerline-raw which-func-format nil 'l))
                                         (powerline-raw " ")
                                         (funcall separator-left mode-line face1)
                                         (when (boundp 'erc-modified-channels-object)
                                           (powerline-raw erc-modified-channels-object face1 'l))
                                         (powerline-major-mode face1 'l)
                                         (powerline-process face1)
                                         (powerline-minor-modes face1 'l)
                                         (powerline-narrow face1 'l)
                                         (powerline-raw " " face1)
                                         (funcall separator-left face1 face2)
                                         (powerline-vc face2 'r)
                                         (when (bound-and-true-p nyan-mode)
                                           (powerline-raw (list (nyan-create)) face2 'l))))
                              (rhs (list (powerline-raw global-mode-string face2 'r)
                                         (when (bound-and-true-p venv-current-name)
                                           (powerline-raw venv-current-name face2 'r))
                                         (funcall separator-right face2 face1)
                                         (unless window-system
                                           (powerline-raw (char-to-string #xe0a1) face1 'l))
                                         (powerline-raw "%4l" face1 'l)
                                         (powerline-raw ":" face1 'l)
                                         (powerline-raw "%3c" face1 'r)
                                         (funcall separator-right face1 mode-line)
                                         (powerline-raw " ")
                                         (powerline-raw "%6p" nil 'r)
                                         (when powerline-display-hud
                                           (powerline-hud face2 face1)))))
                         (concat (powerline-render lhs)
                                 (powerline-fill face2 (powerline-width rhs))
                                 (powerline-render rhs)))))))
    (belak/powerline-theme)

    (setq powerline-display-mule-info nil
          powerline-display-buffer-size nil
          powerline-display-hud nil))
#+end_src

*** Basic setup

Set up some smarter defaults, and make sure that some useful
environment vars (like HOME and GOPATH) are copied into the emacs env.

This section was originally based off of [[https://github.com/technomancy/better-defaults/blob/d62a5813fa60d4c9425a795d85f956f0b8a663f8/better-defaults.el][better defaults]] but it has
since grown to be a bit more than that.

First we clean up the interface a bit, removing menus, toolbars and
the scrollbar. Then we make sure we never get dialog boxes.

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)

  (setq use-dialog-box nil
        use-file-dialog nil)
#+end_src

Because I often make silly window mistakes, we enable winner-mode so
we can undo them.

#+begin_src emacs-lisp
  (winner-mode 1)
#+end_src

=ace-window= is a simpler way to jump around windows.

#+begin_src emacs-lisp
  (use-package ace-window
    :bind ("M-p" . ace-window))
#+end_src

Because I want zap-to-char to not nuke the character we're zapping to,
we simply replace it with zap-up-to-char.

#+begin_src emacs-lisp
  (autoload 'zap-up-to-char "misc")

  (global-set-key [remap zap-to-char] 'zap-up-to-char)
#+end_src

Make sure we actually use the clipboard we want because X is annoying
and has something along the lines of 3 clipboard buffers.

#+begin_src emacs-lisp
  (setq x-select-enable-clipboard t
        x-select-enable-primary t
        x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
        save-interprogram-paste-before-kill t)
#+end_src

Disable startup screen and just display the scratch buffer.

#+begin_src emacs-lisp
  (setq initial-buffer-choice t
        inhibit-startup-screen t)
#+end_src

Make sure that things like backups make it into their own directory
and not the current one.

#+begin_src emacs-lisp
  (defvar save-place-file)
  (setq save-place-file (concat user-emacs-directory "places")
        backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                 "backups"))))
#+end_src

Change search functions to use regexp searches by default.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "M-%") 'query-replace-regexp)
#+end_src

Anzu will show how many seach results we got.

#+begin_src emacs-lisp
  (use-package anzu
    :diminish anzu-mode
    :config
    (global-anzu-mode +1))
#+end_src

Popwin makes completion windows open in a sane location.

#+begin_src emacs-lisp
  (use-package popwin
    :config (popwin-mode 1))
#+end_src

General annoyances.

- Make sure the buffer name shows up with a directory if there are multiple with the same name
- Save the place in the file
- Show parens
- Show parens as quickly as possible
- Don't indent with tabs
- Ask y or n, not yes or no
- When matching parens, highlight the region
- Make extra functions show up when searching
- Change yanking locations
- Turn off the damn bell
- Require a final newline on files
- Follow symlinks when we need to
- Make sure to load newest versions of files, even if there are older compiled versions
- Ensure tabs show up as 4 spaces
- Hide pointer when we start typing
- Ensure we get unified diffs
- Enable focus follows mouse

#+begin_src emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)

  (require 'saveplace)
  (setq-default save-place t)

  (show-paren-mode 1)

  (setq-default indent-tabs-mode nil)

  (fset 'yes-or-no-p 'y-or-n-p)

  (setq show-paren-style 'expression
        show-paren-delay 0
        apropos-do-all t
        mouse-yank-at-point t
        ring-bell-function 'ignore
        lazy-highlight-initial-delay 0
        require-final-newline t
        vc-follow-symlinks t
        load-prefer-newer t
        tab-width 4
        make-pointer-invisible t
        diff-switches "-u")
        ;;mouse-autoselect-window t
#+end_src

Make mouse scrolling and scrolling in general a bit saner (in theory)

#+begin_src emacs-lisp
  (setq mouse-wheel-progressive-speed nil
        mouse-wheel-follow-mouse t
        scroll-step 1)
  ;; (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))
  ;;       mouse-wheel-follow-mouse t
  ;;       scroll-step 1)
#+end_src

Load some useful variables from the shell. By default, it grabs HOME,
but we grab GOPATH as well for go.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (add-to-list 'exec-path-from-shell-variables "GOPATH")
    (exec-path-from-shell-initialize))
#+end_src

*** Evil Mode

Turn on evil mode everywhere. There are some articles that say "don't
do this" and others which will say it's a good idea. I personally like
having evil everywhere, even if there aren't bindings for some things.

#+begin_src emacs-lisp
  (use-package evil
    :config
    ;; Set the powerline colors to mostly line up with the cursor state
    (use-package powerline-evil
      :config
      (set-face-background 'powerline-evil-emacs-face    (belak/zenburn-color "red"))
      (set-face-background 'powerline-evil-insert-face   (belak/zenburn-color "red"))
      (set-face-background 'powerline-evil-motion-face   (belak/zenburn-color "magenta"))
      (set-face-background 'powerline-evil-normal-face   (belak/zenburn-color "green"))
      (set-face-background 'powerline-evil-operator-face (belak/zenburn-color "cyan"))
      (set-face-background 'powerline-evil-replace-face  (belak/zenburn-color "red"))
      (set-face-background 'powerline-evil-visual-face   (belak/zenburn-color "orange")))

    ;; There is a note saying that evil-leader should be enabled before
    ;; evil-mode so it will work in buffers like *scratch* and friends.
    (use-package evil-leader
      :config
      (global-evil-leader-mode)
      (setq evil-leader/leader ","))

    ;; This is a port of tpope's vim-surround which adds text objects
    ;; for surrounding characters.
    (use-package evil-surround
      :config
      (global-evil-surround-mode 1))

    (evil-mode 1)
    (setq evil-echo-state nil
          evil-vsplit-window-right t
          evil-split-window-below t)

    ;; Paradox is much more useful in emacs mode than evil mode because
    ;; it rebinds so many things.
    (add-to-list 'evil-emacs-state-modes 'paradox-menu-mode)

    ;; Set the cursor color based on the evil state
    (setq evil-emacs-state-cursor    (list (belak/zenburn-color "red")     'box)
          evil-insert-state-cursor   (list (belak/zenburn-color "red")     'bar)
          evil-motion-state-cursor   (list (belak/zenburn-color "magenta") 'box)
          evil-normal-state-cursor   (list (belak/zenburn-color "green")   'box)
          evil-replace-state-cursor  (list (belak/zenburn-color "red")     'bar)
          evil-visual-state-cursor   (list (belak/zenburn-color "orange")  'box))

    ;; For the operator state, the only thing we want to change is the
    ;; size. We can keep the same color.
    (setq evil-operator-state-cursor 'evil-half-cursor)

    ;; Make C-a and C-e work closer to how emacs uses them by default
    (bind-keys :map evil-insert-state-map
               ("C-e" . evil-append-line)
               ("C-a" . evil-insert-line))
    (bind-keys :map evil-normal-state-map
               ("C-e" . evil-append-line)
               ("C-a" . evil-insert-line))
    (bind-keys :map evil-motion-state-map
               ("C-e" . evil-append-line)
               ("C-a" . evil-insert-line))
    (bind-keys :map evil-visual-state-map
               ("C-e" . evil-end-of-line)
               ("C-a" . evil-beginning-of-line)))
#+end_src

As a former vim user, I like escape to actually quit everywhere. This
was taken from https://github.com/davvil/.emacs.d/blob/master/init.el

#+begin_src emacs-lisp
  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
    In Delete Selection mode, if the mark is active, just deactivate it;
    then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark  t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
  (global-set-key [escape] 'evil-exit-emacs-state)
#+end_src

*** Navigation

Smooth scroll makes sure there's a buffer between the top of the
window and the cursor.

#+begin_src emacs-lisp
  (use-package smooth-scrolling
    :config
    (setq smooth-scroll-margin 5
          scroll-conservatively 101
          scroll-preserve-screen-position t
          auto-window-vscroll nil
          scroll-margin 5))
#+end_src

Make sure to use ido everywhere.

#+begin_src emacs-lisp
  (use-package ido
    :config
    (use-package smex
      :bind
      ("M-x" . smex)
      ("M-X" . smex-major-mode-commands)
      :config
      (evil-leader/set-key "x" 'smex))

    (use-package ido-ubiquitous
      :config
      (ido-ubiquitous-mode 1))

    (use-package ido-vertical-mode
      :config
      (setq ido-vertical-define-keys 'C-n-C-p-up-down-left-right
            ido-vertical-show-count t)
      (ido-vertical-mode 1))

    (use-package ido-describe-bindings
      :bind
      ("C-c h k" . ido-describe-bindings))

    (use-package flx-ido
      :config
      (flx-ido-mode 1)
      (setq ido-enable-flex-matching t
            flx-ido-threshold 1000))

    (ido-mode 1)
    (ido-everywhere 1)
    (setq resize-mini-windows t
          ido-use-virtual-buffers t)
    (evil-leader/set-key
      "b" 'ido-switch-buffer
      "f" 'ido-find-file))
#+end_src

Make sure we store recent files. This lets helm do fancy things.

#+begin_src emacs-lisp
  (require 'recentf)
  (recentf-mode 1)
#+end_src

Helm is a much fancier replacement for ido.

#+begin_src emacs-lisp
  (use-package helm
    :disabled t
    :diminish helm-mode
    :bind
    ("M-x"     . helm-M-x)
    ("C-x b"   . helm-mini)
    ("C-x C-f" . helm-find-files)
    :config
    (use-package helm-ag
      :commands
      helm-ag
      helm-ag-project-root)

    (use-package helm-swoop
      :bind ("C-S-s" . helm-swoop)
      :config
      (setq helm-swoop-speed-or-color t
            helm-swoop-pre-input-function (lambda () "")))

    ;; Reverse tab and C-z
    (bind-keys :map helm-map
               ("<tab>" . helm-execute-persistent-action)
               ("C-z"   . helm-select-action))

    (bind-keys :map org-mode-map
               ("C-c h" . helm-org-in-buffer-headings))

    (helm-mode 1)

    ;; Resize based on the number of results
    (helm-autoresize-mode 1)

    ;; Turn on fuzzy matching for everything we can
    (setq helm-M-x-fuzzy-match t
          helm-mode-fuzzy-match t
          helm-completion-in-region-fuzzy-match)

    ;; Set leader binds for all the stuff above
    (evil-leader/set-key
      "x"  'helm-M-x
      "hb" 'helm-mini
      "hf" 'helm-find-files))

#+end_src

Perspective creates different views to switch between. This needs to
be loaded on startup so the modeline is set up.

#+begin_src emacs-lisp
  (use-package perspective
    :disabled t
    :config
    (persp-mode))
#+end_src

Project based navigation. I would be completely lost without this.

#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config
    (use-package helm-projectile
      :disabled t
      :config
      (setq projectile-completion-system 'helm)
      (helm-projectile-on)
      (evil-leader/set-key
        "pp" 'helm-projectile-switch-project
        "pf" 'helm-projectile-find-file))
    (projectile-global-mode)
    (evil-leader/set-key
      "pp" 'projectile-switch-project
      "pf" 'projectile-find-file))

#+end_src

=which-key= is a fancier replacement for guide-key. It also makes it
very easy to fix the missing prefix commands, which was something that
really bugged me about guide-key.

#+begin_src emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :config
    (which-key-mode 1)
    (setq which-key-idle-delay 0.5
          which-key-popup-type 'side-window
          which-key-side-window-location 'right))
#+end_src

*** Platform specifics

Font overrides as well as a few mac specific key binds to make emacs
easier to use. Additionally, in OSX we want to toggle fullscreen
because we want to be in full screen more often than not.

#+begin_src emacs-lisp
  (cond ((gnu-linux-p)
         (setq x-gtk-use-system-tooltips nil
               my/default-frame-font "Terminus 8"
               browse-url-browser-function 'browse-url-generic
               browse-url-generic-program "xdg-open"))

        ((osx-p)
         (setq ns-use-native-fullscreen t
               mac-command-modifier 'meta
               mac-option-modifier 'super
               mac-control-modifier 'control
               insert-directory-program "/usr/local/bin/gls"
               my/default-frame-font "Source Code Pro Light 10")

         (toggle-frame-fullscreen)))

  (set-frame-font my/default-frame-font)
#+end_src

*** Search

Add some simple search functions.

#+begin_src emacs-lisp
  (use-package ag)
#+end_src

** Programming
*** General

Set a few things for prog-mode based major modes, such as line numbers
and trailing whitespace.

Note that because =electric-pair-mode= is a global mode we don't
bother putting it into the prog mode hook.

#+begin_src emacs-lisp
  (electric-pair-mode 1)
  (which-function-mode 1)

  (defun my-prog-mode-hook ()
    "Some simple programming settings"
    (interactive)
    (linum-mode 1)
    (setq show-trailing-whitespace t))

  (use-package linum-relative)

  (add-hook 'prog-mode-hook 'my-prog-mode-hook)

  (require 'eldoc)
  (diminish 'eldoc-mode)

  (require 'subword)
  (diminish 'subword-mode)

  (global-prettify-symbols-mode +1)
#+end_src

=fic-mode= makes sure I actually notice comments with TODO, FIXME and
XXX.

#+begin_src emacs-lisp
  (use-package fic-mode
    :diminish fic-mode
    :config
    (add-hook 'prog-mode-hook 'turn-on-fic-mode))
#+end_src

=rainbow-delimiters= is for more than just parentheses. It works for
brackets as well. This mode makes it easier to see nested delimiters.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

*** Version Control

Magit is an amazing git wrapper which lets us do a whole ton of
different things.

The filenotify package will automatically update the status buffer
when files change, but this only appears to work on linux.

#+begin_src emacs-lisp
  (use-package magit
    :bind
    ("M-g M-g" . magit-status)
    :init
    (use-package magit-filenotify
      :if (gnu-linux-p)
      :config
      (add-hook 'magit-status-mode-hook 'magit-filenotify-mode))
    :config
    (setq magit-push-always-verify t
          magit-completing-read-function 'magit-ido-completing-read)
    (evil-leader/set-key
      "gg" 'magit-status
      "gb" 'magit-blame-mode))
#+end_src

Make sure the git gutter is loaded. Note that the fringe doesn't work
in console mode, so we fall back to using the margin.

Note that this is actually called in the [[Finalization]] section

#+begin_src emacs-lisp
  (use-package diff-hl
    :config
    (defun make-frame-diff-hl ()
      (global-diff-hl-mode 0)
      (diff-hl-margin-mode 0)
      (if (display-graphic-p)
          (global-diff-hl-mode 1)
        (diff-hl-margin-mode 1))))
#+end_src

Disable most of the vc backends.

#+begin_src emacs-lisp
  (setq vc-handled-backends '(Git Hg))
#+end_src

With vc related stuffs, it's nice to revert buffers automatically if
they've changed on disk.

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
  (setq auto-revert-verbose nil)
#+end_src

*** Completion

There are two main completion packages. =auto-complete= is older and a
bit rougher around the edges. =company= is newer and not everything
works with it yet, but at least for me it has a tendency to be more
stable.

#+begin_src emacs-lisp
  (use-package company
    :diminish company-mode
    :config
    (setq company-idle-delay 0
          company-echo-delay 0
          company-minimum-prefix-length 1)
    (global-company-mode))
#+end_src

*** Snippets

Not much to say here. We turn snippets on everywhere.

#+begin_src emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :config
    (setq yas-verbosity 0)
    (yas-global-mode 1))
#+end_src

*** Syntax Checking

Turn on syntax checking using flycheck. Because it has so many built
in, in most instances we won't even need to install a plugin.

#+begin_src emacs-lisp
  (use-package flycheck
    :diminish flycheck-mode
    :config
    (defalias 'flycheck-show-error-at-point-soon 'flycheck-show-error-at-point)
    (global-flycheck-mode)
    (which-key-add-key-based-replacements "C-c !" "Flycheck"))

  (use-package flyspell
    :diminish flyspell-mode
    :config
    (add-hook 'text-mode-hook (lambda () (flyspell-mode 1))))
#+end_src

*** Languages
**** Lisp

Rainbow blocks highlights blocks instead of keywords.

#+begin_src emacs-lisp
  (use-package rainbow-blocks
    :disabled t
    :config
    (add-hook 'emacs-lisp-mode-hook 'rainbow-blocks-mode)
    (add-hook 'lisp-interaction-mode-hook 'rainbow-blocks-mode))
#+end_src

Make common symbols prettier.

#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (push '("lambda" . ?λ) prettify-symbols-alist)))
  (add-hook 'clojure-mode-hook
            (lambda ()
              (push '("fn" . ?ƒ) prettify-symbols-alist)))
#+end_src

Install a few packages for playing around with clojure dev.

#+begin_src emacs-lisp
  (add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)

  (use-package clojure-mode
    :mode "\\.clj\\'")

  (use-package cider)
#+end_src

**** C/C++

#+begin_src emacs-lisp
  (use-package irony
    :diminish irony-mode
    :config
    (use-package company-irony
      :config
      (defun my-company-irony-mode-hook ()
        (set (make-local-variable 'company-backends) '(company-irony))
        (company-irony-setup-begin-commands))
      (add-hook 'irony-mode-hook 'my-company-irony-mode-hook))

    (use-package flycheck-irony
      :config
      (eval-after-load 'flycheck
        '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup)))

    (defun my-c-hook ()
      (when (member major-mode irony-supported-major-modes)
        (irony-mode 1)))

    (add-hook 'c++-mode-hook  'my-c-hook)
    (add-hook 'c-mode-hook    'my-c-hook)
    (add-hook 'objc-mode-hook 'my-c-hook)

    ;; replace the `completion-at-point' and `complete-symbol' bindings
    ;; in irony-mode's buffers by irony-mode's function and run the
    ;; autosetup function
    (defun my-irony-mode-hook ()
      (subword-mode 1)
      (define-key irony-mode-map [remap completion-at-point]
        'irony-completion-at-point-async)
      (define-key irony-mode-map [remap complete-symbol]
        'irony-completion-at-point-async)
      (irony-cdb-autosetup-compile-options))

    (add-hook 'irony-mode-hook 'my-irony-mode-hook))
#+end_src

**** Go

This enables most of the fairly standard things available in other go
setups. Simple completion and gofmt are the most important of those
features, at least to me.

#+begin_src emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'"
    :config
    (use-package company-go
      :config
      (add-to-list 'company-backends 'company-go))
      ;;(defun my-company-go-mode-hook ()
      ;;  (set (make-local-variable 'company-backends) '(company-go)))
      ;;(add-hook 'go-mode-hook 'my-company-go-mode-hook)

    ;; Unfortunately, go oracle isn't in any of the package archives
    (load "$GOPATH/src/golang.org/x/tools/cmd/oracle/oracle.el")
    (load "$GOPATH/src/github.com/golang/lint/misc/emacs/golint.el")
    
    (defun my-go-mode-hook ()
      (subword-mode 1))
    (add-hook 'go-mode-hook 'my-go-mode-hook)
    (add-hook 'before-save-hook 'gofmt-before-save)
    (setq gofmt-command "goimports"))
#+end_src

**** PHP

Enable PHP mode

#+begin_src emacs-lisp
  (use-package php-mode
    :mode "\\.php\\'"
    :config
    (defun my-php-mode-hook ()
      (subword-mode 1))
    (add-hook 'php-mode-hook 'my-php-mode-hook))
#+end_src

**** Python

Elpy does *all* the things, so we just use that.

#+begin_src emacs-lisp
  (use-package elpy
    :disabled t
    :config
    (setq elpy-modules (remove 'elpy-module-flymake elpy-modules))
    (elpy-enable))
#+end_src

Anaconda mode does navigation, docs and auto-completion. Because
that's pretty much all I need, I use this in place of elpy.

We set python-mode to load on .py files as a hack to get anaconda-mode
to load in the background.

#+begin_src emacs-lisp
  (use-package anaconda-mode
    :diminish anaconda-mode
    :config
    (use-package company-anaconda
      :config
      (add-to-list 'company-backends 'company-anaconda))
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'eldoc-mode))
#+end_src

This is a reimplementation of virtualenvwrapper in emacs. We need to
load it right away to make sure the modeline is updated.

#+begin_src emacs-lisp
  (use-package virtualenvwrapper
    :config
    (setq virtualenv-location (expand-file-name "~/.virtualenvs/")))
#+end_src

**** Rust

Add support for rust files. =rust-mode= adds syntax support while
racer adds completion and eldoc. Note that racer requires an external
utility to be installed, similar to how gocode works.

#+begin_src emacs-lisp
  (use-package rust-mode
    :config
    (use-package racer
      :config
      (add-hook 'rust-mode-hook #'racer-mode)
      (add-hook 'racer-mode-hook #'eldoc-mode)))
#+end_src

**** Web Dev

These are any packages useful for web dev.

Most of this section is just supporting additional formats, however
=rainbow-mode= is here so we can preview the actual colors in css.

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :commands rainbow-mode)

  (use-package web-mode
    :mode
    "\\.jinja\\'"
    "\\.html\\'"
    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2))

  (use-package less-css-mode
    :mode "\\.less\\'")
#+end_src

There's quite a bit of js stuff. We update the js2-error faces to
match flycheck and make sure tern is enabled.

#+begin_src emacs-lisp
  (use-package js2-mode
    ;; We only need flycheck for the faces we need to inherit from
    :mode
    "\\.js\\'"
    :config
    (setq js2-basic-offset 2)
    (set-face-attribute 'js2-error nil
                        :inherit 'flycheck-error-list-error
                        :underline '(:color foreground-color :style wave))
    (set-face-attribute 'js2-warning nil
                        :inherit 'flycheck-error-list-warning
                        :underline '(:color foreground-color :style wave)))

  (use-package tern
    :config
    (use-package company-tern
      :config
      (add-to-list 'company-backends 'company-tern)
      (setq company-tern-property-marker ""))

    ;; We don't need to depend on js2-mode because this will work
    ;; without it if it doesn't load for whatever reason.
    (add-hook 'js-mode-hook (lambda () (tern-mode t))))
#+end_src

**** Markup

Most markup modes are derived from text-mode, so we can turn on
auto-fill for all of them.

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (diminish 'auto-fill-function)
#+end_src

Make markdown-mode use gfm-markdown because it has most of the
extensions I care about.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode ("\\.md\\'" . gfm-mode))
#+end_src

**** Source Pawn

This isn't perfect, but we need a way to add a mode which won't be
used by irony but is still a close approximation of the SourcePawn
source, so we define a major mode derived from =c++-mode=.

#+begin_src emacs-lisp
  (define-derived-mode sourcepawn-mode c++-mode "SourcePawn")
  (use-package sourcepawn-mode
    :ensure f
    :mode "\\.sp\\'")
#+end_src

**** Misc

#+begin_src emacs-lisp
  (use-package cmake-mode
    :mode
    "CMakeLists\\.txt\\'"
    "\\.cmake\\'")

  (use-package dockerfile-mode
    :mode "Dockerfile\(-.*\)?")

  (use-package elixir-mode
    :disabled t
    :mode "\\.exs?\\'"
    :config
    (use-package alchemist))

  (use-package erlang
    :disabled t
    :mode ("\\.erl\\'" . erlang-mode))

  (use-package json-mode
    :mode "\\.json\\'")

  (use-package julia-mode
    :mode "\\.jl\\'")

  (use-package lua-mode
    :mode "\\.lua\\'")

  (use-package todotxt-mode
    :disabled t
    :mode "todo.txt")

  (use-package toml-mode
    :mode "\\.toml\\'")

  (use-package yaml-mode
    :mode "\\.yml\\'")
#+end_src

** Utilities

This section is mostly about replacing or improving built-in
functionality such as the package list or dired. There are also a few
packages which work well as stand-alone units in here such as
undo-tree and which-key.

*** Package list

Paradox is a replacement for =package-list-packages= offering a few
extra features. Note that we only load it on those commands because
it's something that only really matters when we manually start it up.

#+begin_src emacs-lisp
  (use-package paradox
    :disabled t
    :commands
    paradox-list-packages
    paradox-enable
    :config
    (setq paradox-automatically-star t)
    (setq paradox-execute-asynchronously t))
#+end_src

*** HTTP docs

Add some useful HTTP docs.

#+begin_src emacs-lisp
  (use-package know-your-http-well
    :commands (http-header
               http-method
               http-relation
               http-status-code))
#+end_src

*** Dired

Make a few improvements to dired.

Additionally, do our best to make sure that we don't litter the buffer list with
dired buffers.

#+begin_src emacs-lisp
  (use-package dired+
    :config
    (use-package dired-single
      :config
      (defun belak/dired-up ()
        (interactive)
        (dired-single-buffer ".."))

      (defun belak/dired-select ()
        (interactive)
        (let ((prev-buffer (current-buffer)))
          (dired-single-buffer)
          (if (eq 'dired-mode (with-current-buffer prev-buffer major-mode))
              (kill-buffer prev-buffer))))

      (bind-keys :map dired-mode-map
                 ("<return>"  . belak/dired-select)
                 ("^"         . belak/dired-up)
                 ("q"         . kill-this-buffer))))
#+end_src

Make dired navigation much prettier.

#+begin_src emacs-lisp
  (use-package stripe-buffer
    :config
    (add-hook 'dired-mode-hook 'stripe-listify-buffer))
#+end_src

*** Scratch

This enables persistent scratch buffers. This allows for saving
scratch buffers along with the mode because I prefer to use org-mode.

#+begin_src emacs-lisp
  (use-package persistent-scratch
    :config
    (persistent-scratch-setup-default)
    (persistent-scratch-autosave-mode 1))
#+end_src

*** IRC

This sets up the connection to my IRC bouncer. There are a few
additional packages that would be useful here, such as znc, but I
still prefer to keep my IRC in weechat, so this remains disabled for
now.

#+begin_src emacs-lisp
  (use-package erc
    :disabled t
    :config
    (setq erc-prompt ">"
          erc-join-buffer 'bury)
          erc-track-exclude-types '("JOIN" "PART" "QUIT" "NICK" "MODE"))
#+end_src

We add in ZNC support so we can detatch from buffers when we leave the
channel. This is used along with autojoin so when something happens in
a buffer, it pops up again.

Additionally, there's an added advantage that this is lazy-loaded
because it doesn't require the password prompt until we want to
connect.

#+begin_src emacs-lisp
  (use-package znc
    :disabled t
    :commands
    znc-erc
    znc-all
    :config
    (setq znc-detatch-on-kill t
          znc-servers `(("znc.coded.io" "6697" t
                         ((freenode
                           belak/freenode
                           ,(password-store-get "irc/freenode.net")))))))
#+end_src

*** Email

Email is a complicated beast. This is currently designed around a
custom mail server, something I didn't want to deal with maintaining,
so this section isn't that useful right now.

#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
  (use-package mu4e
    :ensure f
    :commands
    mu4e
    :config
    (setq mu4e-maildir "~/.mail"
          mu4e-get-mail-command "mbsync -a"
          mu4e-html2text-command "elinks -dump"
          mu4e-use-fancy-chars nil
          mu4e-confirm-quit nil
          message-kill-buffer-on-exit t
          mu4e-change-filenames-when-moving t
          mu4e-sent-folder   "/Sent"
          mu4e-drafts-folder "/Drafts"
          mu4e-trash-folder  "/Trash"
          mu4e-refile-folder "/Archive"
          mu4e-maildir-shortcuts '(("/Inbox"   . ?i)
                                   ("/Drafts"  . ?d)
                                   ("/Sent"    . ?s)
                                   ("/Archive" . ?a)
                                   ("/Spam"    . ?z)
                                   ("/Trash"   . ?t)))

    (setq send-mail-function 'smtpmail-send-it
          message-send-mail-function 'smtpmail-send-it
          smtpmail-default-smtp-server "mail.messagingengine.com"
          smtpmail-smtp-server "mail.messagingengine.com"
          smtpmail-stream-type 'ssl
          smtpmail-smtp-service 465)

    ;; custom move to trash
    ;; https://groups.google.com/forum/#!topic/mu-discuss/m4ORymDlf0E
    (defun my/mu4e-headers-mode-trash ()
      (interactive)
      (mu4e-mark-set 'move mu4e-trash-folder)
      (mu4e-headers-next))

    (defun my/mu4e-view-mode-trash ()
      (interactive)
      (mu4e~view-in-headers-context
       (my/mu4e-headers-mode-trash)))

    (define-key mu4e-headers-mode-map (kbd "d") 'my/mu4e-headers-mode-trash)
    (define-key mu4e-view-mode-map (kbd "d") 'my/mu4e-view-mode-trash)

    (defvar belak/mu4e-send-map '()
      "Simple mapping of the 'To' header to the outgoing address.")
    (defvar belak/mu4e-default-email ""
      "Email to use when the send-map does not contain a matching address.")

    (defun belak/mu4e-compose-hook ()
      (setq user-mail-address
            (let ((msg mu4e-compose-parent-message))
              (cl-labels ((f (l)
                             (cond ((not msg) belak/mu4e-default-email)
                                   ((not l) belak/mu4e-default-email)
                                   ((mu4e-message-contact-field-matches msg :to (car (car l)))
                                    (cdr (car l)))
                                   (t (f (car l))))))
                (f belak/mu4e-send-map))))

      (add-hook 'mu4e-compose-pre-hook 'belak/mu4e-compose-hook)))
#+end_src

*** Misc

Make sure undo-tree is enabled.

#+begin_src emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :config
    (global-undo-tree-mode 1))
#+end_src

** Org Mode

Make sure org mode is set up in a manner that doesn't suck. Meaning,
make code blocks act more like their native counterparts, enable fancy
indenting and allow for shift select.

If the extra require looks hacky, that's because it is. The =:demand=
makes sure the config runs because the package is already loaded to
run this config file. The =:diminish= keyword fails because
org-indent-mode does not exist by the time diminish is called.

#+begin_src emacs-lisp
  (use-package org
    :demand
    :mode ("\\.org\\'" . org-mode)
    :diminish org-indent-mode
    :init
    (require 'org-indent)
    :config
    (setq org-completion-use-ido t
          org-src-fontify-natively t
          org-src-tab-acts-natively t
          org-log-done t
          org-log-done-with-time t
          org-log-refile t
          org-refile-allow-creating-parent-nodes t
          org-refile-use-outline-path t
          org-support-shift-select t
          org-tag-alist '(("WORK" . ?w)
                          ("HOME" . ?h))
          org-agenda-files '("~/org/"))
    (add-hook 'org-mode-hook 'auto-fill-mode))
#+end_src

** Custom

We still want to be able to have non-public configs, such as for
passwords and what not, so we put them in a separate file and load it,
but ignore errors, for instance if it doesn't exist.

This also makes it so customizations will go to this file and not to
the init.el, which we have version controlled.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file t)
#+end_src

** Finalization

Make sure everything is set up correctly depending on if we're
daemonized or not. Unfortunately =after-make-frame-functions= fires
before the config is loaded when emacs is not daemonized.

#+begin_src emacs-lisp
  (defun my-make-frame-functions (&optional frame)
    (if frame
        (select-frame frame))
    (if (fboundp 'make-frame-diff-hl)
        (make-frame-diff-hl))
    (set-frame-font my/default-frame-font))

  (if (daemonp)
      (add-hook 'after-make-frame-functions 'my-make-frame-functions)
    (my-make-frame-functions))
#+end_src

Now that we're done, we can turn off error handling.

#+begin_src emacs-lisp
  (setq debug-on-error nil)
  (setq debug-on-quit nil)
#+end_src

** TODO Tasks [4/14]

This section is all about stuff I'd like to get into my emacs init but
haven't found the time yet.

- [X] Reorganize based on http://doc.rix.si/org/fsem.html
- [X] Make =subword-mode= diminish work correctly
- [X] Fix fci mode so it works with company mode
- [X] Everyone seems to like popwin, so we should probably at least try to figure out why
- [ ] Add some ag bindings
- [ ] Look into ranger and improving my dired setup
- [ ] Learn =paredit=
- [ ] Look into avy
- [ ] Look into slime for elisp
- [ ] Set up ediff like https://github.com/dakrone/dakrone-dotfiles/blob/master/.emacs.d/settings.org#ediff
- [ ] Set up smartparens like https://github.com/dakrone/dakrone-dotfiles/blob/master/.emacs.d/settings.org#smartparens
- [ ] Set up anzu like https://github.com/dakrone/dakrone-dotfiles/blob/master/.emacs.d/settings.org#anzu
- [ ] Find a way to bootstrap go-oracle
- [ ] Move away from org-mode config
